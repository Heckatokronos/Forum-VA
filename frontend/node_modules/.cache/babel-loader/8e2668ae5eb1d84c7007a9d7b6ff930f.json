{"ast":null,"code":"/**\n * This file contains an runtime version of `styled` component. Responsibilities of the component are:\n * - returns ReactElement based on HTML tag used with `styled` or custom React Component\n * - injects classNames for the returned component\n * - injects CSS variables used to define dynamic styles based on props\n */\nimport React from 'react';\nimport validAttr from '@emotion/is-prop-valid';\nimport { cx } from '@linaria/core'; // Workaround for rest operator\n\nexport const restOp = (obj, keys) => {\n  const res = {};\n  let key;\n\n  for (key in obj) {\n    if (keys.indexOf(key) === -1) {\n      res[key] = obj[key];\n    }\n  }\n\n  return res;\n};\n\nconst warnIfInvalid = (value, componentName) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof value === 'string' || // eslint-disable-next-line no-self-compare\n    typeof value === 'number' && isFinite(value)) {\n      return;\n    }\n\n    const stringified = typeof value === 'object' ? JSON.stringify(value) : String(value); // eslint-disable-next-line no-console\n\n    console.warn(`An interpolation evaluated to '${stringified}' in the component '${componentName}', which is probably a mistake. You should explicitly cast or transform the value to a string.`);\n  }\n};\n\nfunction styled(tag) {\n  return options => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (Array.isArray(options)) {\n        // We received a strings array since it's used as a tag\n        throw new Error('Using the \"styled\" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup');\n      }\n    }\n\n    const render = (props, ref) => {\n      const {\n        as: component = tag,\n        class: className\n      } = props;\n      const rest = restOp(props, ['as', 'class']);\n      let filteredProps; // Check if it's an HTML tag and not a custom element\n\n      if (typeof component === 'string' && component.indexOf('-') === -1) {\n        filteredProps = {}; // eslint-disable-next-line guard-for-in\n\n        for (const key in rest) {\n          if (key === 'as' || validAttr(key)) {\n            // Don't pass through invalid attributes to HTML elements\n            filteredProps[key] = rest[key];\n          }\n        }\n      } else {\n        filteredProps = rest;\n      }\n\n      filteredProps.ref = ref;\n      filteredProps.className = cx(filteredProps.className || className, options.class);\n      const {\n        vars\n      } = options;\n\n      if (vars) {\n        const style = {}; // eslint-disable-next-line guard-for-in\n\n        for (const name in vars) {\n          const variable = vars[name];\n          const result = variable[0];\n          const unit = variable[1] || '';\n          const value = typeof result === 'function' ? result(props) : result;\n          warnIfInvalid(value, options.name);\n          style[`--${name}`] = `${value}${unit}`;\n        }\n\n        const ownStyle = filteredProps.style || {};\n        const keys = Object.keys(ownStyle);\n\n        if (keys.length > 0) {\n          keys.forEach(key => {\n            style[key] = ownStyle[key];\n          });\n        }\n\n        filteredProps.style = style;\n      }\n\n      if (tag.__linaria && tag !== component) {\n        // If the underlying tag is a styled component, forward the `as` prop\n        // Otherwise the styles from the underlying component will be ignored\n        filteredProps.as = component;\n        return /*#__PURE__*/React.createElement(tag, filteredProps);\n      }\n\n      return /*#__PURE__*/React.createElement(component, filteredProps);\n    };\n\n    const Result = React.forwardRef ? /*#__PURE__*/React.forwardRef(render) : // React.forwardRef won't available on older React versions and in Preact\n    // Fallback to a innerRef prop in that case\n    props => {\n      const rest = restOp(props, ['innerRef']);\n      return render(rest, props.innerRef);\n    };\n    Result.displayName = options.name; // These properties will be read by the babel plugin for interpolation\n\n    Result.__linaria = {\n      className: options.class,\n      extends: tag\n    };\n    return Result;\n  };\n}\n\nexport default process.env.NODE_ENV !== 'production' ? new Proxy(styled, {\n  get(o, prop) {\n    return o(prop);\n  }\n\n}) : styled;","map":{"version":3,"mappings":"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","names":["React","validAttr","cx","restOp","obj","keys","res","key","indexOf","warnIfInvalid","value","componentName","process","env","NODE_ENV","isFinite","stringified","JSON","stringify","String","console","warn","styled","tag","options","Array","isArray","Error","render","props","ref","as","component","class","className","rest","filteredProps","vars","style","name","variable","result","unit","ownStyle","Object","length","forEach","__linaria","createElement","Result","forwardRef","innerRef","displayName","extends","Proxy","get","o","prop"],"sources":["D:\\Projects\\GitHub\\frontend\\dev\\node_modules\\@linaria\\react\\src\\styled.ts"],"sourcesContent":["/**\n * This file contains an runtime version of `styled` component. Responsibilities of the component are:\n * - returns ReactElement based on HTML tag used with `styled` or custom React Component\n * - injects classNames for the returned component\n * - injects CSS variables used to define dynamic styles based on props\n */\nimport React from 'react';\nimport validAttr from '@emotion/is-prop-valid';\nimport { cx } from '@linaria/core';\nimport type { CSSProperties, StyledMeta } from '@linaria/core';\n\nexport type NoInfer<A extends any> = [A][A extends any ? 0 : never];\n\ntype Options = {\n  name: string;\n  class: string;\n  vars?: {\n    [key: string]: [\n      string | number | ((props: unknown) => string | number),\n      string | void\n    ];\n  };\n};\n\ninterface CustomOmit {\n  <T extends object, K extends [...(keyof T)[]]>(obj: T, keys: K): {\n    [K2 in Exclude<keyof T, K[number]>]: T[K2];\n  };\n}\n\n// Workaround for rest operator\nexport const restOp: CustomOmit = (obj, keys) => {\n  const res = {} as { [K in keyof typeof obj]: typeof obj[K] };\n  let key: keyof typeof obj;\n  for (key in obj) {\n    if (keys.indexOf(key) === -1) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n};\n\nconst warnIfInvalid = (value: any, componentName: string) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (\n      typeof value === 'string' ||\n      // eslint-disable-next-line no-self-compare\n      (typeof value === 'number' && isFinite(value))\n    ) {\n      return;\n    }\n\n    const stringified =\n      typeof value === 'object' ? JSON.stringify(value) : String(value);\n\n    // eslint-disable-next-line no-console\n    console.warn(\n      `An interpolation evaluated to '${stringified}' in the component '${componentName}', which is probably a mistake. You should explicitly cast or transform the value to a string.`\n    );\n  }\n};\n\ninterface IProps {\n  className?: string;\n  style?: Record<string, string>;\n  [props: string]: unknown;\n}\n\n// If styled wraps custom component, that component should have className property\nfunction styled<TConstructor extends React.ComponentType<any>>(\n  tag: TConstructor extends React.ComponentType<infer T>\n    ? [T] extends [{ className?: string | undefined }]\n      ? TConstructor\n      : never\n    : never\n): ComponentStyledTag<TConstructor>;\nfunction styled<T>(\n  tag: [T] extends [{ className?: string | undefined }]\n    ? React.ComponentType<T>\n    : never\n): ComponentStyledTag<T>;\nfunction styled<TName extends keyof JSX.IntrinsicElements>(\n  tag: TName\n): HtmlStyledTag<TName>;\nfunction styled(tag: any): any {\n  return (options: Options) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (Array.isArray(options)) {\n        // We received a strings array since it's used as a tag\n        throw new Error(\n          'Using the \"styled\" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup'\n        );\n      }\n    }\n\n    const render = (props: any, ref: any) => {\n      const { as: component = tag, class: className } = props;\n      const rest = restOp(props, ['as', 'class']);\n      let filteredProps: IProps;\n\n      // Check if it's an HTML tag and not a custom element\n      if (typeof component === 'string' && component.indexOf('-') === -1) {\n        filteredProps = {} as { [key: string]: any };\n\n        // eslint-disable-next-line guard-for-in\n        for (const key in rest) {\n          if (key === 'as' || validAttr(key)) {\n            // Don't pass through invalid attributes to HTML elements\n            filteredProps[key] = rest[key];\n          }\n        }\n      } else {\n        filteredProps = rest;\n      }\n\n      filteredProps.ref = ref;\n      filteredProps.className = cx(\n        filteredProps.className || className,\n        options.class\n      );\n\n      const { vars } = options;\n\n      if (vars) {\n        const style: { [key: string]: string } = {};\n\n        // eslint-disable-next-line guard-for-in\n        for (const name in vars) {\n          const variable = vars[name];\n          const result = variable[0];\n          const unit = variable[1] || '';\n          const value = typeof result === 'function' ? result(props) : result;\n\n          warnIfInvalid(value, options.name);\n\n          style[`--${name}`] = `${value}${unit}`;\n        }\n\n        const ownStyle = filteredProps.style || {};\n        const keys = Object.keys(ownStyle);\n        if (keys.length > 0) {\n          keys.forEach((key) => {\n            style[key] = ownStyle[key];\n          });\n        }\n\n        filteredProps.style = style;\n      }\n\n      if ((tag as any).__linaria && tag !== component) {\n        // If the underlying tag is a styled component, forward the `as` prop\n        // Otherwise the styles from the underlying component will be ignored\n        filteredProps.as = component;\n\n        return React.createElement(tag, filteredProps);\n      }\n      return React.createElement(component, filteredProps);\n    };\n\n    const Result = React.forwardRef\n      ? React.forwardRef(render)\n      : // React.forwardRef won't available on older React versions and in Preact\n        // Fallback to a innerRef prop in that case\n        (props: any) => {\n          const rest = restOp(props, ['innerRef']);\n          return render(rest, props.innerRef);\n        };\n\n    (Result as any).displayName = options.name;\n\n    // These properties will be read by the babel plugin for interpolation\n    (Result as any).__linaria = {\n      className: options.class,\n      extends: tag,\n    };\n\n    return Result;\n  };\n}\n\ntype StyledComponent<T> = StyledMeta &\n  ([T] extends [React.FunctionComponent<any>]\n    ? T\n    : React.FunctionComponent<T & { as?: React.ElementType }>);\n\ntype StaticPlaceholder = string | number | CSSProperties | StyledMeta;\n\ntype HtmlStyledTag<TName extends keyof JSX.IntrinsicElements> = <\n  TAdditionalProps = {}\n>(\n  strings: TemplateStringsArray,\n  ...exprs: Array<\n    | StaticPlaceholder\n    | ((\n        // Without Omit here TS tries to infer TAdditionalProps\n        // from a component passed for interpolation\n        props: JSX.IntrinsicElements[TName] & Omit<TAdditionalProps, never>\n      ) => string | number)\n  >\n) => StyledComponent<JSX.IntrinsicElements[TName] & TAdditionalProps>;\n\ntype ComponentStyledTag<T> = <\n  OwnProps = {},\n  TrgProps = [T] extends [React.FunctionComponent<infer TProps>] ? TProps : T\n>(\n  strings: TemplateStringsArray,\n  // Expressions can contain functions only if wrapped component has style property\n  ...exprs: TrgProps extends { style?: React.CSSProperties | undefined }\n    ? Array<\n        | StaticPlaceholder\n        | ((props: NoInfer<OwnProps & TrgProps>) => string | number)\n      >\n    : StaticPlaceholder[]\n) => keyof OwnProps extends never\n  ? [T] extends [React.FunctionComponent<any>]\n    ? StyledMeta & T\n    : StyledComponent<TrgProps>\n  : StyledComponent<OwnProps & TrgProps>;\n\ntype StyledJSXIntrinsics = {\n  readonly [P in keyof JSX.IntrinsicElements]: HtmlStyledTag<P>;\n};\n\nexport type Styled = typeof styled & StyledJSXIntrinsics;\n\nexport default (process.env.NODE_ENV !== 'production'\n  ? new Proxy(styled, {\n      get(o, prop: keyof JSX.IntrinsicElements) {\n        return o(prop);\n      },\n    })\n  : styled) as Styled;\n"]},"metadata":{},"sourceType":"module"}